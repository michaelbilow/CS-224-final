__author__ = 'michael'

import os
import sys
from create_hash_table import read_chromosome, hash_chromosome
import numpy as np
import math
from collections import defaultdict
import swalign


MIN_DIST_BETWEEN_READS = 80
MAX_DIST_BETWEEN_READS = 120
INDEL_CUTOFF = 20


def locations_to_peaks(locations, key_length, bp_error_probability=.02):
    """
    Converts the start locations generated by a single read
    into a dict of probabilities.

    Uses an HMM-like rule to give the likelihood of a particular string.
    """

    exact_match_probability = (1.0 - bp_error_probability) ** key_length
    exact_match_log_p = math.log(exact_match_probability)
    average_error_log_p = math.log(1.0 - exact_match_probability) - key_length * math.log(4)
    #  First term: leftover probability, second term: number of possible key_length strings
    bp_error_log_p = math.log(bp_error_probability)

    peaks = [([(np.nan, np.nan, np.nan, np.nan)],  # Peaks have the form: [[list of start locations],
              #     start location = (chromosome index, implied start point,
              #                       actual start point, end point)
              0,  # log_probability,
              ['E'])]  # string of whether the match at this position is perfect or not,

    # We initialize with np.nan to stand in for
    # all other non-aligning sequences in the genome.
    for i in range(len(locations)):
        location_list = locations[i]
        implied_start_location_list = [x[:-1] for x in location_list]
        location_used = [False for x in range(len(location_list))]
        default_error_log_p = i * average_error_log_p
        new_peaks = []
        for j in range(len(peaks)):
            peak = peaks[j]
            peak_history = peak[0]
            log_p = peak[1]
            match_qualities = peak[2]
            current_start_and_end_loc = peak_history[-1]  # The last start_loc is where the current one starts.
            implied_start_loc = current_start_and_end_loc[:2]  #
            chrom_distances = [chromosome_signed_distance(loc, implied_start_loc)
                               for loc in implied_start_location_list]

            match_indices = [k for k in range(len(chrom_distances)) if chrom_distances[k] == 0]
            assert len(match_indices) <= 1  # There can be at most one perfect match.
            if match_indices:
                match_index = match_indices[0]
                match_location = location_list[match_index]
                new_peak_history = peak_history + [match_location]
                new_log_p = log_p + exact_match_log_p
                new_match_qualities = match_qualities + ['M']
                new_peak = (new_peak_history, new_log_p, new_match_qualities)
                new_peaks.append(new_peak)
                location_used[match_index] = True
            else:  # If there is no perfect match, extend the match with an error
                error_location = (current_start_and_end_loc[0],
                                  current_start_and_end_loc[1],
                                  current_start_and_end_loc[3],
                                  current_start_and_end_loc[3] + key_length)
                error_peak_history = peak_history + [error_location]
                error_peak_log_p = log_p + average_error_log_p
                error_match_quality = match_qualities + ['E']
                error_peak = (error_peak_history, error_peak_log_p, error_match_quality)
                new_peaks.append(error_peak)

            indel_indices = [k for k in range(len(chrom_distances)) if 0 < abs(chrom_distances[k]) <= INDEL_CUTOFF]

            for indel_index in indel_indices:
                ## Create new peaks with the indel, and one where it is interpreted as an error
                indel_location = location_list[indel_index]
                indel_peak_start_locs = peak_history + [indel_location]
                indel_length = chrom_distances[indel_index]
                indel_peak_log_p = log_p + exact_match_probability + indel_length * bp_error_log_p
                if indel_length > 0:
                    indel_match_qualities = match_qualities + ['I' + str(indel_length)]
                elif indel_length < 0:
                    indel_match_qualities = match_qualities + ['D' + str(abs(indel_length))]
                indel_peak = (indel_peak_start_locs, indel_peak_log_p, indel_match_qualities)
                new_peaks.append(indel_peak)

        ## Now, we need to add in peaks for the unused locations
        for j in range(len(location_list)):
            if location_used[j]:  # If the peak had an exact match, we assume that's the correct place for it to align.
                continue
            else:  # If not, we construct a new sequence of errors followed by a single match.
                match_location = location_list[j]
                new_peak_history = [(match_location[0],
                                     match_location[1],
                                     match_location[1] + key_length * k,
                                     match_location[1] + (key_length + 1) * k)
                                    for k in range(i)]
                new_peak_history += [match_location]
                new_peak_log_p = default_error_log_p + exact_match_log_p
                new_peak_match_qualities = ['E']*i + ['M']
                new_peak = (new_peak_history, new_peak_log_p, new_peak_match_qualities)
                new_peaks.append(new_peak)

        peaks = new_peaks

    return peaks


def generate_implied_start_sequence(location, key_length, i):
    chromosome = location[0]
    implied_start_loc = location[1]

    new_locations = [(chromosome,
                      implied_start_loc,
                      implied_start_loc + j * key_length,
                      implied_start_loc + (j + 1) * key_length)
                     for j in range(i)]

    return new_locations


def chromosome_signed_distance(loc1, loc2):
    """
    Computes a "chromosomal" distance between two locations of the form
    loc = (chromsome number, chromosome coordinate)
    where the two reads are considered an infinite distance apart if
    they are on different chromosomes
    """
    if loc1[0] != loc2[0]:
        return np.inf
    else:
        return loc1[1] - loc2[1]


def map_end(read_end, key_length, genome_hash):
    """
    Cut the read into disjoint pieces of length
    key_length, and try to align them using the hash.

    Input:
    read_end,    the bases in one end of a paired-end read
    key_length,  the length of the keys used in the genome_hash
    genome_hash, a hash of the reference genome that returns the
                 starting position of the match for each
                 of the exact matches of each key in the genome.

    Output: [list of peaks] peaks defined up top.
    """
    all_locations = []
    for i in range(len(read_end) / key_length):
        offset = i * key_length
        key = read_end[offset: offset + key_length]
        locations = [(start_loc[0],  # The chromosome that the read is on
                      start_loc[1] - offset,  # The "implied start location" of the read
                      start_loc[1],  # The actual start location of the read
                      start_loc[1] + key_length)  # The actual end of the read.
                     for start_loc in genome_hash[key]]
        all_locations.append(locations)
    peaks = locations_to_peaks(all_locations, key_length)
    print all_locations

    for p in peaks:
        print p

    # check_peaks_against_reference(peaks, read_end, reference)
    return peaks


def check_peaks_against_reference(peaks, read, reference):
    """
    Using the peaks as a guide, we check the read against the reference.
    First, we set a cutoff for the quality of the alignment
      that is, it must be at least more likely than the average likelihood
      of an entire random genome aligning to this particular read.

      That probability is |N|*p_0, where p_0 is the probability that
      nothing aligns. ----Eh, I'm not sure about this number yet, but it seems like a good cutoff for now.

    Once the peaks have been filtered, each peak is attempted to be aligned with the
    genome. Perfectly-matching strings are skipped, and imperfectly matching strings are mapped using
    a Smith-Waterman dynamic programming algorithm.
    """
    null_alignment_log_p = min([peak[1] for peak in peaks])
    ref_length = len(reference)
    log_p_cutoff = math.log(ref_length) + null_alignment_log_p
    peaks = [peak for peak in peaks if peak[1] > log_p_cutoff]

    for peak in peaks:
        peak_CIGAR = ''
        unaligned_ref_start = np.nan
        unaligned_ref_end = np.nan
        unaligned_read_start = np.nan
        unaligned_read_end = np.nan
        offsets = peak[0]
        for i in range(len(offsets)):
            read_start = i * read_length
            offset = offsets[i]
            alignment_start = offset + read_start
            alignment_quality = peak[2][i]
            if alignment_quality == 'E':
                if unaligned_read_start is np.nan:
                    unaligned_ref_start = alignment_start
                    unaligned_read_start = read_start
                else:
                    pass

                if i == len(offsets) - 1:
                    unaligned_ref_end = alignment_start + read_length  # Note that it is not necessarily the
                    # case that the unaligned
                    # read should end exactly where the alignment
                    # ends, but fuck it for now.
                    unaligned_read_end = read_start + read_length

                    ref_seq = reference[unaligned_ref_start: unaligned_ref_end]
                    read_seq = read[unaligned_read_start: unaligned_read_end]

                    segment_CIGAR = smith_waterman(ref_seq, read_seq)
                    unaligned_read_start = np.nan
                    unaligned_read_end = np.nan

                else:
                    segment_CIGAR = ''
            else:  # First, clear the error-reads if necessary
                unaligned

            if alignment_quality == 'M':
                if unaligned_read_start is not np.nan:
                    segment_CIGAR = smith_waterman(unaligned_read_start, unaligned_read_end, reference)
                else:
                    segment_CIGAR = ''
                segment_CIGAR += 'M' + str(read_length)
            elif alignment_quality == 'E':
                segment_CIGAR = smith_waterman()
            elif any(x in alignment_quality for x in ('I', 'D')):  # If an insertion or deletion was noticed,
                indel_length = int(alignment_quality[1:])  # check that there is a record of the indel
                # earlier in the peak_CIGAR.
                segment_CIGAR = 'M' + str(read_length)
            else:
                raise

            peak_CIGAR += CIGAR_append(peak_CIGAR, segment_CIGAR)

    return


def CIGAR_append(start_CIGAR, new_CIGAR):
    """
    Appends the CIGAR-formatted
    """

    return


def smith_waterman(read1, read2):
    """
    Does Smith-Waterman dynamic-programming alignment and returns the
    most likely global alignment of the reads read1 and read2, and
    returns the CIGAR representation of the output
    """
    cigar = ''
    return cigar


def align_paired_peaks(peaks1, peaks2, read_length):
    """
    Aligns pairs of peaks, and returns ONE of the following:
    1) the sequence of aligned points for the two reads plus the exact distance between the reads
    2) a flag indicating that the read looks like it aligns, but not in a clean way, for example
        i) One end aligns well, the other doesn't
        ii) Both reads align well, but the distance between them is too large
        iii) There are multiple potential alignments that are about equally good.
        iv)  ???
    3) None, indicating that the read does not align to the genome at all.
    """

    return


def pair_peaks(peaks1, peaks2, read_length):
    peak_pairs = []
    for peak1 in peaks1:
        for peak2 in peaks2:
            start_dist = abs(peak2[0] - peak1[0])
            if MIN_DIST_BETWEEN_READS <= start_dist <= MAX_DIST_BETWEEN_READS:  # This criteria should be
                # made flexible eventually.

                peak_pairs.append((peak1, peak2))
    return peak_pairs


def map_read(paired_end_read, key_length, hash_table):
    """
    Maps a single paired-end read to the genome.
    Each end is mapped to a set of "probabilistic" peaks (the numbers aren't really probabilities)
    Then the ends are aligned to each other, and the alignment is returned.
    """
    end1 = paired_end_read[0]
    end2 = paired_end_read[1]
    peaks1 = map_end(end1, key_length, hash_table)
    peaks2 = map_end(end2, key_length, hash_table)
    # output = pair_peaks(peaks1, peaks2)
    return


def read_and_map_reads(reads_fn, key_length, genome_hash):
    """
    Maps a whole bunch of paired-end reads to a reference genome.
    """
    with open(reads_fn, 'r') as reads_file:
        reads_file.readline()
        reads_file.readline()
        count = 0
        for line in reads_file:
            paired_end_read = line.strip().split(',')
            map_read(paired_end_read, key_length, genome_hash)
            count += 1
            if count > 0:
                break


if __name__ == "__main__":
    input_folder = './EE_genome'
    ref = 'ref/ref_genomeEExample.txt'
    reads = 'reads/reads_genomeEExample.txt'
    ref_fn = os.path.join(input_folder, ref)
    reads_fn = os.path.join(input_folder, reads)
    key_size = 10
    index, seq = read_chromosome(ref_fn)
    my_hash = hash_chromosome(index, seq, key_size)

    read_and_map_reads(reads_fn, key_size, my_hash)